// Generated by Google Gemini
const API_BASE_URL = 'http://localhost:18080';

const headerTargetDisplay = document.getElementById('headerTargetDisplay');
const rowsSelect = document.getElementById('rowsSelect');
const colsSelect = document.getElementById('colsSelect');
const targetTileSelect = document.getElementById('targetTileSelect');
const seedInput = document.getElementById('seedInput');
const randomSeedCheckbox = document.getElementById('randomSeedCheckbox');
const initButton = document.getElementById('initButton');
const undoButton = document.getElementById('undoButtonAlone');
const aboutButton = document.getElementById('aboutButton');

const dirUpButton = document.getElementById('dir-up');
const dirLeftButton = document.getElementById('dir-left');
const dirRightButton = document.getElementById('dir-right');
const dirDownButton = document.getElementById('dir-down');

const sequenceInput = document.getElementById('sequenceInput');
const playSequenceButton = document.getElementById('playSequenceButton');
const sequenceDelayInput = document.getElementById('sequenceDelayInput');

const gameBoardDiv = document.getElementById('gameBoard');
const scoreDisplay = document.getElementById('scoreDisplay');
const stepsDisplay = document.getElementById('stepsDisplay');
const currentSeedDisplay = document.getElementById('currentSeedDisplay');
const targetTileDisplay = document.getElementById('targetTileDisplay');
const gameStatusDisplay = document.getElementById('gameStatus');
const messageDiv = document.getElementById('message');
const aboutContentDiv = document.getElementById('aboutContent');

const autoDecideStartBtn = document.getElementById('autoDecideStartBtn');
const autoDecideStopBtn = document.getElementById('autoDecideStopBtn');


let currentRows = 4;
let currentCols = 4;
let isPlayingSequence = false;
let isAutoDecideRunning = false;
let autoDecidePollingInterval = null;

function generateRandomSeed() {
    return Math.floor(Math.random() * 4294967295);
}

function setControlsDisabled(disabled) {
    initButton.disabled = disabled;
    rowsSelect.disabled = disabled;
    colsSelect.disabled = disabled;
    targetTileSelect.disabled = disabled;
    seedInput.disabled = disabled;
    randomSeedCheckbox.disabled = disabled;
    undoButton.disabled = disabled;
    dirUpButton.disabled = disabled;
    dirLeftButton.disabled = disabled;
    dirRightButton.disabled = disabled;
    dirDownButton.disabled = disabled;
    playSequenceButton.disabled = disabled;
    sequenceInput.disabled = disabled;
    sequenceDelayInput.disabled = disabled;

    if (!disabled) {
        seedInput.disabled = randomSeedCheckbox.checked;
        autoDecideStartBtn.disabled = isAutoDecideRunning;
        autoDecideStopBtn.disabled = !isAutoDecideRunning;
    }
}

function updateAutoDecideButtons(isRunning) {
    isAutoDecideRunning = isRunning;

    if (isRunning) {
        setControlsDisabled(true);
        autoDecideStartBtn.disabled = true;
        autoDecideStopBtn.disabled = false;
    } else {
        setControlsDisabled(false);
        playSequenceButton.disabled = isPlayingSequence;
        sequenceInput.disabled = isPlayingSequence;
        sequenceDelayInput.disabled = false;
    }
}

function startPolling() {
    if (autoDecidePollingInterval) stopPolling();

    const pollInterval = Math.max(50, parseInt(sequenceDelayInput.value) / 2 || 100);

    const poll = async () => {
        const isRunning = await checkAutoDecideStatus();
        if (isRunning) {
            await updateDisplay();
        } else {
            stopPolling();
            await updateDisplay();
        }
    };

    poll();
    autoDecidePollingInterval = setInterval(poll, pollInterval);
}

function stopPolling() {
    if (autoDecidePollingInterval) {
        clearInterval(autoDecidePollingInterval);
        autoDecidePollingInterval = null;
    }
}

async function checkAutoDecideStatus() {
    try {
        const response = await fetch(`${API_BASE_URL}/autodecidestatus`);
        if (!response.ok) return false;

        const data = await response.json();
        const isRunning = data.is_running;

        if (isAutoDecideRunning !== isRunning) {
            updateAutoDecideButtons(isRunning);
        }
        return isRunning;
    } catch (error) {
        stopPolling();
        updateAutoDecideButtons(false);
        return false;
    }
}

async function updateDisplay() {
    try {
        const response = await fetch(`${API_BASE_URL}/board`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        updateDisplayFromData(data.board, data.score, data.steps, data.stuck, data.reached_target || false, data.rows, data.cols, data.current_seed, data.target_tile);
    } catch (error) {
        console.error("Error fetching board state:", error);
        messageDiv.textContent = "Error: Could not connect to game backend. Please ensure the C++ backend is running.";
    }
}

async function initGame() {
    if (isPlayingSequence || isAutoDecideRunning) {
        messageDiv.textContent = "Cannot start new game while sequence or AI is running.";
        return;
    }

    await stopAutoDecide(true);

    const rows = parseInt(rowsSelect.value);
    const cols = parseInt(colsSelect.value);
    const targetTile = parseInt(targetTileSelect.value);

    let seed = 0;

    if (randomSeedCheckbox.checked) {
        seed = generateRandomSeed();
    } else {
        const inputSeed = parseInt(seedInput.value);
        if (!isNaN(inputSeed) && inputSeed >= 0) {
            seed = inputSeed;
        } else {
            alert('Please enter a valid non-negative integer seed, or select random seed.');
            seedInput.value = '';
            randomSeedCheckbox.checked = true;
            seedInput.disabled = true;
            seed = generateRandomSeed();
        }
    }

    try {
        const requestBody = { rows: rows, cols: cols, target_tile: targetTile, seed: seed };

        const response = await fetch(`${API_BASE_URL}/init`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP Error! Status: ${response.status}, Message: ${errorText}`);
        }

        const data = await response.json();
        updateDisplayFromData(data.board, data.score, data.steps, data.stuck, data.reached_target, data.rows, data.cols, data.current_seed, data.target_tile);
        messageDiv.textContent = data.message;
    } catch (error) {
        console.error('Error initializing game:', error);
        messageDiv.textContent = `Error initializing game: ${error.message}. Please ensure the C++ backend is running.`;
    }
}

async function undoMove() {
    if (isAutoDecideRunning || isPlayingSequence) {
        messageDiv.textContent = "Undo disabled while AI or Sequence is running.";
        return false;
    }

    try {
        const response = await fetch(`${API_BASE_URL}/undo`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`HTTP Error! Status: ${response.status}, Message: ${errorData.error || response.statusText}`);
        }

        const data = await response.json();
        messageDiv.textContent = data.message;
        updateDisplayFromData(data.board, data.score, data.steps, data.stuck, data.reached_target, data.rows, data.cols, data.current_seed, data.target_tile);
        return data.status === 'success';
    } catch (error) {
        console.error('Error during undo operation:', error);
        messageDiv.textContent = `Error during undo operation: ${error.message}.`;
        return false;
    }
}

async function sendMove(direction) {
    if (isAutoDecideRunning || isPlayingSequence) {
        messageDiv.textContent = "Manual moves disabled while AI or Sequence is running.";
        return false;
    }

    try {
        const response = await fetch(`${API_BASE_URL}/play`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ direction: direction })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`HTTP Error! Status: ${response.status}, Message: ${errorData.error || response.statusText}`);
        }

        const data = await response.json();

        let dir_info = "";
        switch (direction) {
            case 'w': dir_info = "upward"; break;
            case 'a': dir_info = "leftward"; break;
            case 's': dir_info = "downward"; break;
            case 'd': dir_info = "rightward"; break;
        }

        if (data.moved) {
            messageDiv.textContent = `Moved ${dir_info}.`;
        } else {
            messageDiv.textContent = `Cannot move ${dir_info}.`;
        }

        updateDisplayFromData(data.board, data.score, data.steps, data.stuck, data.reached_target, data.rows, data.cols, data.current_seed, data.target_tile);
        return data.moved;
    }
    catch (error) {
        console.error('Error sending move operation:', error);
        messageDiv.textContent = `Error sending move operation: ${error.message}.`;
        return false;
    }
}

async function startAutoDecide() {
    if (isAutoDecideRunning) return;

    const interval_ms = parseInt(sequenceDelayInput.value);
    if (isNaN(interval_ms) || interval_ms < 20) {
        messageDiv.textContent = "Invalid Delay. Must be at least 20ms.";
        return;
    }

    try {
        const response = await fetch(`${API_BASE_URL}/autodecidestart`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ interval_ms: interval_ms })
        });

        const data = await response.json();
        if (!response.ok) {
            throw new Error(data.error || response.statusText);
        }

        messageDiv.textContent = data.message;
        updateAutoDecideButtons(true);
        startPolling();
    } catch (error) {
        messageDiv.textContent = `Error starting AI: ${error.message}`;
        updateAutoDecideButtons(false);
        stopPolling();
    }
}

async function stopAutoDecide(silent = false) {
    if (!isAutoDecideRunning) return;

    try {
        const response = await fetch(`${API_BASE_URL}/autodecidestop`, { method: 'POST' });
        const data = await response.json();

        if (!silent) {
            messageDiv.textContent = data.message;
        }

        updateAutoDecideButtons(false);
        stopPolling();
        await updateDisplay();

    } catch (error) {
        if (!silent) {
            messageDiv.textContent = `Error stopping AI: ${error.message}`;
        }
        updateAutoDecideButtons(false);
        stopPolling();
    }
}

async function playSequence() {
    if (isPlayingSequence || isAutoDecideRunning) {
        messageDiv.textContent = isAutoDecideRunning ? "Cannot play sequence while AI is running." : "A sequence is already playing.";
        return;
    }

    const sequence = sequenceInput.value.toLowerCase().trim();
    if (!sequence) {
        messageDiv.textContent = "Please enter a sequence to play.";
        return;
    }

    const delay = parseInt(sequenceDelayInput.value);
    if (isNaN(delay) || delay < 20) {
        messageDiv.textContent = "Invalid delay. Sequence canceled.";
        return;
    }

    isPlayingSequence = true;
    setControlsDisabled(true);
    sequenceDelayInput.disabled = false;
    sequenceInput.disabled = false;

    messageDiv.textContent = "Playing sequence...";

    for (let i = 0; i < sequence.length; i++) {
        const char = sequence[i];
        let handled = false;

        const boardResponse = await fetch(`${API_BASE_URL}/board`);
        const boardData = await boardResponse.json();
        if (boardData.stuck || boardData.reached_target) {
            messageDiv.textContent = boardData.stuck ? "Sequence stopped: Game Over (Stuck)." : "Sequence stopped: Target Reached.";
            break;
        }

        if (char === 'z') {
            await undoMoveSequence();
            handled = true;
        } else if (['w', 'a', 's', 'd'].includes(char)) {
            await sendMoveSequence(char);
            handled = true;
        } else if (char !== ' ') {
            messageDiv.textContent = `Skipping unknown char '${char}'...`;
            await new Promise(resolve => setTimeout(resolve, 50));
        }

        if (handled) {
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }

    if (isPlayingSequence) {
        messageDiv.textContent = "Sequence playback finished.";
    }

    isPlayingSequence = false;
    setControlsDisabled(false);
    updateAutoDecideButtons(false);

}

async function sendMoveSequence(direction) {
    try {
        const response = await fetch(`${API_BASE_URL}/play`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ direction: direction })
        });
        const data = await response.json();
        updateDisplayFromData(data.board, data.score, data.steps, data.stuck, data.reached_target, data.rows, data.cols, data.current_seed, data.target_tile);
    } catch (error) {
        messageDiv.textContent = `Sequence Error: Move failed. ${error.message}`;
        isPlayingSequence = false;
    }
}

async function undoMoveSequence() {
    try {
        const response = await fetch(`${API_BASE_URL}/undo`, { method: 'POST' });
        const data = await response.json();
        updateDisplayFromData(data.board, data.score, data.steps, data.stuck, data.reached_target, data.rows, data.cols, data.current_seed, data.target_tile);
    } catch (error) {
        messageDiv.textContent = `Sequence Error: Undo failed. ${error.message}`;
        isPlayingSequence = false;
    }
}


function updateDisplayFromData(boardString, score, steps, stuck, reachedTarget, rows, cols, seed, target_tile) {
    currentRows = rows;
    currentCols = cols;
    gameBoardDiv.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
    const TILE_SIZE = 75;
    const GAP_SIZE = 5;
    const boardWidth = cols * TILE_SIZE + (cols + 1) * GAP_SIZE;
    const boardHeight = rows * TILE_SIZE + (rows + 1) * GAP_SIZE;
    gameBoardDiv.style.width = `${boardWidth}px`;
    gameBoardDiv.style.height = `${boardHeight}px`;
    gameBoardDiv.innerHTML = '';

    const rowsArray = boardString.trim().split('\n');
    rowsArray.forEach(rowString => {
        const tiles = rowString.split(' ').map(Number);
        tiles.forEach(tileValue => {
            const tileDiv = document.createElement('div');
            tileDiv.classList.add('tile');
            if (tileValue > 0) {
                let className = `tile-${tileValue}`;
                if (tileValue > 8192) {
                    className = 'tile-super';
                } else if (tileValue === 8192) {
                    className = 'tile-8192';
                } else if (tileValue === 4096) {
                    className = 'tile-4096';
                }
                tileDiv.classList.add(className);
            }
            tileDiv.textContent = tileValue === 0 ? '' : tileValue;
            gameBoardDiv.appendChild(tileDiv);
        });
    });

    headerTargetDisplay.textContent = target_tile;
    scoreDisplay.textContent = score;
    stepsDisplay.textContent = steps;
    currentSeedDisplay.textContent = seed;
    targetTileDisplay.textContent = target_tile;

    let statusText = 'Game in progress';
    gameStatusDisplay.style.color = 'black';

    if (reachedTarget) {
        statusText = 'Congratulations, you reached the target!';
        gameStatusDisplay.style.color = 'green';
        if (isAutoDecideRunning) stopAutoDecide(false);
    } else if (stuck) {
        statusText = 'Game Over! (No more moves)';
        gameStatusDisplay.style.color = 'red';
        if (isAutoDecideRunning) stopAutoDecide(false);
    }
    gameStatusDisplay.textContent = statusText;
}

async function handleKeyPress(event) {
    if (isAutoDecideRunning || isPlayingSequence) return;

    const targetTagName = event.target.tagName.toLowerCase();
    if (targetTagName === 'input' || targetTagName === 'textarea' || targetTagName === 'select') {
        return;
    }
    let direction = '';
    switch (event.key) {
        case 'w':
        case 'W':
        case 'ArrowUp':
            direction = 'w';
            break;
        case 'a':
        case 'A':
        case 'ArrowLeft':
            direction = 'a';
            break;
        case 's':
        case 'S':
        case 'ArrowDown':
            direction = 's';
            break;
        case 'd':
        case 'D':
        case 'ArrowRight':
            direction = 'd';
            break;
        case 'z':
        case 'Z':
            event.preventDefault();
            await undoMove();
            return;
    }

    if (direction) {
        event.preventDefault();
        await sendMove(direction);
    }
}

async function toggleAboutContent() {
    if (aboutContentDiv.style.display === 'block') {
        aboutContentDiv.style.display = 'none';
        aboutContentDiv.textContent = '';
    } else {
        try {
            const response = await fetch(`${API_BASE_URL}/about`);
            if (!response.ok) {
                throw new Error(`HTTP Error! Status: ${response.status}`);
            }
            const text = await response.text();
            let aboutInfo = text;

            aboutInfo += "\n\n--- Seed Information ---\n";
            aboutInfo += "If 'Random' is chosen, the game will ignore the input seed and randomly choose a seed.\n";

            aboutInfo += "\n--- Controls ---\n";
            aboutInfo += "Keyboard: Use W, A, S, D or Arrow Keys for movement.\n";
            aboutInfo += "Press 'Z' to Undo the last move.\n";
            aboutInfo += "\n--- Control Sequence / AI Information ---\n";
            aboutInfo += "The 'Step Delay' is used for BOTH sequence playback and AI execution speed.\n";
            aboutInfo += "Paste your \"wsadz\" sequence to simulate keyboard input at the specified delay.\n";
            aboutInfo += "Start AI to let the C++ 'Decide' function play automatically.\n";
            aboutInfo += "\nIf the backend 'Decide' function is time-consuming, time per move might be much longer than the 'delay' set.\n";

            aboutContentDiv.textContent = aboutInfo;
            aboutContentDiv.style.display = 'block';
        } catch (error) {
            console.error('Error fetching about content:', error);
            aboutContentDiv.textContent = `Could not load about content: ${error.message}`;
            aboutContentDiv.style.display = 'block';
        }
    }
}

randomSeedCheckbox.addEventListener('change', () => {
    seedInput.disabled = randomSeedCheckbox.checked;
    if (randomSeedCheckbox.checked) {
        seedInput.value = '';
    }
});

initButton.addEventListener('click', initGame);
undoButton.addEventListener('click', undoMove);
aboutButton.addEventListener('click', toggleAboutContent);
dirUpButton.addEventListener('click', () => sendMove('w'));
dirLeftButton.addEventListener('click', () => sendMove('a'));
dirRightButton.addEventListener('click', () => sendMove('d'));
dirDownButton.addEventListener('click', () => sendMove('s'));

playSequenceButton.addEventListener('click', playSequence);
autoDecideStartBtn.addEventListener('click', startAutoDecide);
autoDecideStopBtn.addEventListener('click', stopAutoDecide);

document.addEventListener('keydown', handleKeyPress);

seedInput.disabled = randomSeedCheckbox.checked;
initGame();