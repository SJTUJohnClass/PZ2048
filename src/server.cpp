// Generated by Google gemini
#include "game_logic.h"
#include "user_logic.h"
#include <iostream>
#include <stdexcept>
#include <random>
#include <algorithm>
#include <string>
#include <thread>
#include <chrono>
#include <atomic>
#include <sstream>
#include "crow/middlewares/cors.h"
#include "../third_party/Crow/include/crow.h"

std::atomic<bool> is_auto_decide_running{false};

void auto_decide_loop(int interval_ms) {
    PZ2048::ClientPrepare(PZ2048::GetRows(), PZ2048::GetCols());

    try {
        while (is_auto_decide_running.load()) {
            if (PZ2048::Stuck() || PZ2048::HasReachedTarget()) {
                is_auto_decide_running.store(false);
                break;
            }

            // Capture board state using standard C++ streams (as required by original PZ2048 interface)
            std::ostringstream oss;
            std::streambuf* obuf = std::cout.rdbuf(oss.rdbuf());
            PZ2048::PrintBoard();
            std::cout.rdbuf(obuf);

            std::istringstream iss(oss.str());
            std::streambuf* ibuf = std::cin.rdbuf(iss.rdbuf());
            PZ2048::ReadBoard();
            std::cin.rdbuf(ibuf);

            char oper = PZ2048::Decide();
            if (oper == 'w' || oper == 's' || oper == 'a' || oper == 'd') {
                PZ2048::TryRun(oper);
            } else {
                is_auto_decide_running.store(false);
            }

            if (is_auto_decide_running.load()) {
                std::this_thread::sleep_for(std::chrono::milliseconds(interval_ms));
            }
        }
    } catch (...) {
        is_auto_decide_running.store(false);
    }
}

crow::json::wvalue GetCurrentStateJson() {
    crow::json::wvalue data;
    data["board"] = PZ2048::SerializeBoard();
    data["score"] = PZ2048::Score();
    data["steps"] = PZ2048::Steps();
    data["stuck"] = PZ2048::Stuck();
    data["rows"] = PZ2048::GetRows();
    data["cols"] = PZ2048::GetCols();
    data["reached_2048"] = PZ2048::HasReachedTarget();
    data["target_tile"] = PZ2048::GetTarget();
    data["current_seed"] = PZ2048::GetCurrentSeed();
    return data;
}

int main() {
    crow::App<crow::CORSHandler> app;

    auto& cors = app.get_middleware<crow::CORSHandler>();
    cors
        .global()
        .origin("*")
        .methods("POST"_method)
        .methods("GET"_method)
        .methods("OPTIONS"_method)
        .headers("Content-Type")
        .max_age(86400);

    app.port(18080).multithreaded();

    CROW_ROUTE(app, "/")([](){
        crow::response res("Hello from C++ 2048 Backend!");
        return res;
    });

    CROW_ROUTE(app, "/init")
    .methods("POST"_method)([&](const crow::request& req){
        // Stop AI if it's running before initializing a new game
        if (is_auto_decide_running.load()) {
            is_auto_decide_running.store(false);
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }

        crow::json::rvalue request_body_json;
        int rows = 4;
        int cols = 4;
        int target_tile = 2048;
        unsigned int user_provided_seed = 0;

        try {
            request_body_json = crow::json::load(req.body);
            if (request_body_json.has("rows") && request_body_json["rows"].t() == crow::json::type::Number) {
                rows = static_cast<int>(request_body_json["rows"].d());
            }
            if (request_body_json.has("cols") && request_body_json["cols"].t() == crow::json::type::Number) {
                cols = static_cast<int>(request_body_json["cols"].d());
            }
            if (request_body_json.has("target_tile") && request_body_json["target_tile"].t() == crow::json::type::Number) {
                target_tile = static_cast<int>(request_body_json["target_tile"].d());
            }
            if (request_body_json.has("seed") && request_body_json["seed"].t() == crow::json::type::Number) {
                user_provided_seed = static_cast<unsigned int>(request_body_json["seed"].d());
            }
        } catch (const std::runtime_error& e) {
        }

        rows = std::max(1, std::min(10, rows));
        cols = std::max(1, std::min(10, cols));

        PZ2048::Start(rows, cols, target_tile, user_provided_seed);

        crow::json::wvalue response_json;
        response_json["message"] = "Game initialized successfully!";
        response_json = GetCurrentStateJson();

        crow::response res(200, response_json);
        res.set_header("Content-Type", "application/json");
        return res;
    });

    CROW_ROUTE(app, "/play")
    .methods("POST"_method)([&](const crow::request& req){
        if (is_auto_decide_running.load()) {
            crow::json::wvalue error_json;
            error_json["error"] = "Manual moves disabled while Auto-Decide is running.";
            crow::response res(403, error_json);
            res.set_header("Content-Type", "application/json");
            return res;
        }

        crow::json::rvalue request_body_json;
        try {
            request_body_json = crow::json::load(req.body);
        } catch (const std::runtime_error& e) {
            crow::json::wvalue error_json;
            error_json["error"] = "Invalid JSON in request body.";
            error_json["details"] = e.what();
            crow::response res(400, error_json);
            res.set_header("Content-Type", "application/json");
            return res;
        }

        std::string direction_str;
        if (request_body_json.has("direction") &&
            request_body_json["direction"].t() == crow::json::type::String) {
            direction_str = request_body_json["direction"].s();
        } else {
            crow::json::wvalue error_json;
            error_json["error"] = "Missing or invalid 'direction' in request body.";
            crow::response res(400, error_json);
            res.set_header("Content-Type", "application/json");
            return res;
        }

        if (direction_str.empty()) {
            crow::json::wvalue error_json;
            error_json["error"] = "'direction' string cannot be empty.";
            crow::response res(400, error_json);
            res.set_header("Content-Type", "application/json");
            return res;
        }

        char dir = direction_str[0];

        bool moved = PZ2048::TryRun(dir);

        crow::json::wvalue response_json = GetCurrentStateJson();
        response_json["status"] = "success";
        response_json["moved"] = moved;

        crow::response res(200, response_json);
        res.set_header("Content-Type", "application/json");
        return res;
    });

    CROW_ROUTE(app, "/undo")
    .methods("POST"_method)([&](){
        if (is_auto_decide_running.load()) {
            crow::json::wvalue error_json;
            error_json["error"] = "Undo disabled while Auto-Decide is running.";
            crow::response res(403, error_json);
            res.set_header("Content-Type", "application/json");
            return res;
        }

        bool undone = PZ2048::Undo();

        crow::json::wvalue response_json = GetCurrentStateJson();
        response_json["status"] = undone ? "success" : "failed";
        response_json["message"] = undone ? "Undo successful." : "No previous move to undo.";

        crow::response res(200, response_json);
        res.set_header("Content-Type", "application/json");
        return res;
    });

    CROW_ROUTE(app, "/board")([](){
        crow::json::wvalue response_json = GetCurrentStateJson();

        crow::response res(200, response_json);
        res.set_header("Content-Type", "application/json");
        return res;
    });

    // --- AI Control Routes ---
    CROW_ROUTE(app, "/autodecidestart")
    .methods("POST"_method)([&](const crow::request& req){
        if (is_auto_decide_running.load()) {
            crow::json::wvalue error_json;
            error_json["error"] = "Auto-Decide is already running.";
            crow::response res(409, error_json);
            res.set_header("Content-Type", "application/json");
            return res;
        }

        if (PZ2048::Stuck() || PZ2048::HasReachedTarget()) {
            crow::json::wvalue error_json;
            error_json["error"] = "Game is already over (stuck or target reached). Please start a new game.";
            crow::response res(400, error_json);
            res.set_header("Content-Type", "application/json");
            return res;
        }

        crow::json::rvalue request_body_json;
        int interval_ms = 500;

        try {
            request_body_json = crow::json::load(req.body);
            if (request_body_json.has("interval_ms") && request_body_json["interval_ms"].t() == crow::json::type::Number) {
                interval_ms = static_cast<int>(request_body_json["interval_ms"].d());
            }
        } catch (const std::runtime_error& e) {}

        interval_ms = std::max(20, interval_ms);

        is_auto_decide_running.store(true);
        std::thread(auto_decide_loop, interval_ms).detach();

        crow::json::wvalue response_json;
        response_json["message"] = "Auto-Decide started successfully.";
        response_json["interval_ms"] = interval_ms;

        crow::response res(200, response_json);
        res.set_header("Content-Type", "application/json");
        return res;
    });

    CROW_ROUTE(app, "/autodecidestop")
    .methods("POST"_method)([&](){
        bool was_running = is_auto_decide_running.load();
        is_auto_decide_running.store(false);

        crow::json::wvalue response_json;
        response_json["message"] = was_running ? "Auto-Decide stop signal sent." : "Auto-Decide was not running.";
        response_json["was_running"] = was_running;

        crow::response res(200, response_json);
        res.set_header("Content-Type", "application/json");
        return res;
    });

    CROW_ROUTE(app, "/autodecidestatus")([](){
        crow::json::wvalue response_json;
        response_json["is_running"] = is_auto_decide_running.load();
        response_json["stuck"] = PZ2048::Stuck();
        response_json["reached_2048"] = PZ2048::HasReachedTarget();
        response_json["score"] = PZ2048::Score();
        response_json["steps"] = PZ2048::Steps();

        crow::response res(200, response_json);
        res.set_header("Content-Type", "application/json");
        return res;
    });
    // -------------------------

    CROW_ROUTE(app, "/about")([](){
        std::string about_content =
            "Welcome to the C++ 2048 Backend!\n\n"
            "This is a simple backend implementation using the Crow C++ web framework.\n"
            "The backend now includes routes for manual play, undo, board status, and AI automatic decision-making.\n\n"
            "Game Logic:\n"
            "- Tiles merge to reach the target tile (default 2048).\n\n"
            "API Routes:\n"
            "- /init (POST): Initialize a new game with optional rows, cols, target_tile, and seed.\n"
            "- /play (POST): Make a move (w, a, s, d).\n"
            "- /undo (POST): Undo the last move.\n"
            "- /board (GET): Get the current board state and stats.\n"
            "- /autodecidestart (POST): Start the AI.\n"
            "- /autodecidestop (POST): Stop the AI.\n"
            "- /autodecidestatus (GET): Check AI status.\n";

        crow::response res(200, about_content);
        res.set_header("Content-Type", "text/plain");
        return res;
    });

    std::cout << "C++ 2048 Backend listening on port 18080..." << std::endl;
    app.run();
    return 0;
}