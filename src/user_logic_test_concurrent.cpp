// Generated by Deepseek
// some subprocess stuff in C.
#include <iostream>
#include <thread>
#include <vector>
#include <sstream>
#include <iomanip>
#include <chrono>
#include <cmath>
#include <sys/wait.h>
#include <poll.h>

#include "game_logic.h"
#include "user_logic.h"

int output_pts(double avg_score) {
  int final_score = static_cast<int>(avg_score + 0.5);
  int res = 0;
  if(final_score < 1000) {
    res = 0;
  } else if(final_score < 3000) {
    res = static_cast<int>(std::ceil(final_score * final_score / 200000.0)) + 30;
  } else if(final_score < 8000) {
    res = static_cast<int>(std::ceil(12.27 * std::log2(final_score / 1000.0) + 55.55));
  } else {
    res = std::min(static_cast<int>(std::ceil(42.92 * std::sqrt(std::log2(final_score / 1000.0)) + 18.16)), 110);
  }
  return res;
}

void run_single_game(int game_id, int rows, int cols, int target, int result_fd) {
  auto game_start_time = std::chrono::steady_clock::now();

  uint seed = game_id + 1;

  PZ2048::ClientPrepare(rows, cols);
  PZ2048::Start(rows, cols, target, seed);

  while(true) {
    std::ostringstream board_stream;
    auto *original_cout_buf = std::cout.rdbuf(board_stream.rdbuf());
    PZ2048::PrintBoard();
    std::cout.rdbuf(original_cout_buf);

    std::istringstream input_stream(board_stream.str());
    auto *original_cin_buf = std::cin.rdbuf(input_stream.rdbuf());
    PZ2048::ReadBoard();
    std::cin.rdbuf(original_cin_buf);

    char oper = PZ2048::Decide();
    if(oper != 'w' && oper != 's' && oper != 'a' && oper != 'd') {
      continue;
    }

    PZ2048::TryRun(oper);

    if(PZ2048::HasReachedTarget() || PZ2048::Stuck()) {
      auto [steps, score] = PZ2048::EndGame();

      auto game_end_time = std::chrono::steady_clock::now();
      auto game_duration = std::chrono::duration_cast<std::chrono::microseconds>(
          game_end_time - game_start_time);
      double game_seconds = game_duration.count() * 1e-6;

      std::string result = "RESULT:" + std::to_string(game_id) + ":" +
        std::to_string(score) + ":" + std::to_string(steps) + ":" +
        std::to_string(game_seconds) + "\n";
      write(result_fd, result.c_str(), result.length());
      break;
    }
  }
  exit(0); // terminate this sub process
}

void concurrent_test_multiprocess() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);

  auto start_time = std::chrono::steady_clock::now();
  long long total_score = 0;
  long long total_steps = 0;
  double total_game_time = 0.0;
  int completed_games = 0;
  int games = 10000;
  int target = 2048;
  int row_num = 4, col_num = 4;
  int next_game_id_to_start = 0;

  unsigned int num_processes = std::min(std::thread::hardware_concurrency(), 16u);
  if(num_processes == 0) num_processes = 4;
  num_processes = std::min(num_processes, (unsigned int)games);

  std::cout << "Using " << num_processes << " processes for " << games << " games" << std::endl;

  std::vector<pid_t> child_pids(num_processes, -1);
  std::vector<std::string> buffers(num_processes);
  std::vector<pollfd> fds(num_processes);

  for(unsigned int p = 0; p < num_processes; ++p) {
    int pipe_fd[2];
    if(pipe(pipe_fd) == -1) {
      std::cerr << "Failed to create pipe." << std::endl;
      return;
    }

    pid_t pid = fork();
    if(pid == 0) {
      close(pipe_fd[0]);
      run_single_game(next_game_id_to_start, row_num, col_num, target, pipe_fd[1]);
      close(pipe_fd[1]);
      exit(0);
    } else if(pid > 0) {
      child_pids[p] = pid;
      close(pipe_fd[1]);
      fds[p].fd = pipe_fd[0];
      fds[p].events = POLLIN;
      next_game_id_to_start++;
    } else {
      std::cerr << "Failed to fork process " << p << std::endl;
      return;
    }
  }

  // initial message
  std::cout << "\rLoading";
  for(int j = 0; j < (completed_games / 100) % 4 + 1; j++) std::cout << ".";
  for(int j = (completed_games / 100) % 4 + 1; j < 4; j++) std::cout << " ";
  std::cout << " [" << std::setw(3) << 0 << "%]";
  std::cout << " | Game: " << std::setw(5) << completed_games << "/" << games;
  std::cout << " | Total time: " << std::setw(5) << std::fixed << std::setprecision(2) << 0 << "s";
  std::cout << " | Avg Game Time: " << std::setw(6) << std::fixed << std::setprecision(3) << 0 << "s";
  std::cout << " | Avg Score: " << std::setw(6) << std::fixed << std::setprecision(2) << 0;
  std::cout << " | Avg Steps: " << std::setw(6) << std::fixed << std::setprecision(2) << 0;
  std::cout.flush();

  while(completed_games < games) {
    int poll_count = poll(fds.data(), num_processes, 100);
    if(poll_count > 0) {
      bool progress_updated = false;
      for(unsigned int i = 0; i < num_processes; ++i) {
        if(fds[i].fd != -1 && (fds[i].revents & (POLLIN | POLLHUP))) {
          char buffer[256];
          ssize_t bytes_read = read(fds[i].fd, buffer, sizeof(buffer) - 1);

          if(bytes_read > 0) {
            buffer[bytes_read] = '\0';
            buffers[i] += buffer;

            size_t pos;
            while((pos = buffers[i].find('\n')) != std::string::npos) {
              std::string line = buffers[i].substr(0, pos);
              buffers[i] = buffers[i].substr(pos + 1);

              if(line.rfind("RESULT:", 0) == 0) {
                try {
                  size_t pos1 = line.find(':', 7);
                  size_t pos2 = line.find(':', pos1 + 1);
                  size_t pos3 = line.find(':', pos2 + 1);

                  int score = std::stoi(line.substr(pos1 + 1, pos2 - pos1 - 1));
                  int steps = std::stoi(line.substr(pos2 + 1, pos3 - pos2 - 1));
                  double game_time = std::stod(line.substr(pos3 + 1));

                  total_score += score;
                  total_steps += steps;
                  total_game_time += game_time;
                  completed_games++;
                  progress_updated = true;
                } catch(...) {
                  std::cerr << "Parse error: " << line << std::endl;
                }
              }
            }
          }

          if(bytes_read == 0 || (fds[i].revents & POLLHUP)) {
            if(child_pids[i] != -1) {
              int status;
              waitpid(child_pids[i], &status, 0);
            }
            close(fds[i].fd);
            fds[i].fd = -1;
            child_pids[i] = -1;

            if(next_game_id_to_start < games) {
              int pipe_fd[2];
              if(pipe(pipe_fd) == -1) {
                std::cerr << "Failed to create new pipe." << std::endl;
                continue;
              }

              pid_t pid = fork();
              if(pid == 0) {
                close(pipe_fd[0]);
                run_single_game(next_game_id_to_start, row_num, col_num, target, pipe_fd[1]);
                exit(0);
              } else if(pid > 0) {
                child_pids[i] = pid;
                close(pipe_fd[1]);
                fds[i].fd = pipe_fd[0];
                fds[i].events = POLLIN;
                next_game_id_to_start++;
              }
            }
          }
        }
      }
      if(progress_updated) {
        double current_avg_score = (completed_games > 0) ? total_score * 1.0 / completed_games : 0;
        double current_avg_steps = (completed_games > 0) ? total_steps * 1.0 / completed_games : 0;
        double current_avg_game_time = (completed_games > 0) ? total_game_time / completed_games : 0;
        auto total_elapsed_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
          std::chrono::steady_clock::now() - start_time);
        double total_elapsed_s = total_elapsed_ms.count() * 0.001;
        int progress_percent = (completed_games * 100) / games;

        std::cout << "\rLoading";
        for(int j = 0; j < (completed_games / 100) % 4 + 1; j++) std::cout << ".";
        for(int j = (completed_games / 100) % 4 + 1; j < 4; j++) std::cout << " ";
        std::cout << " [" << std::setw(3) << progress_percent << "%]";
        std::cout << " | Game: " << std::setw(5) << completed_games << "/" << games;
        std::cout << " | Total time: " << std::setw(5) << std::fixed << std::setprecision(2) << total_elapsed_s << "s";
        std::cout << " | Avg Game Time: " << std::setw(6) << std::fixed << std::setprecision(3) << current_avg_game_time << "s";
        std::cout << " | Avg Score: " << std::setw(6) << std::fixed << std::setprecision(2) << current_avg_score;
        std::cout << " | Avg Steps: " << std::setw(6) << std::fixed << std::setprecision(2) << current_avg_steps;
        std::cout.flush();
      }
    }
  }

  for(int i = 0; i < num_processes; ++i) {
    if(child_pids[i] != -1) {
      int status;
      waitpid(child_pids[i], &status, 0);
    }
    if(fds[i].fd != -1) {
      close(fds[i].fd);
    }
  }

  std::cout << "\r" << std::string(200, ' ') << "\r";
  std::cout.flush();

  auto end_time = std::chrono::steady_clock::now();
  double avg_score = total_score * 1.0 / games;
  double avg_steps = total_steps * 1.0 / games;
  auto total_duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
  double total_wall_time = total_duration.count() * 0.001;
  double avg_game_time = total_game_time / games;

  std::cout << "Average score over " << games << " games: " << avg_score << std::endl;
  std::cout << "Average steps over " << games << " games: " << avg_steps << std::endl;
  std::cout << "Total wall clock time: " << std::fixed << std::setprecision(2) << total_wall_time << "s";
  std::cout << " (" << total_duration.count() / 60000 << "min " << std::fixed << std::setprecision(2) <<
    (total_duration.count() % 60000) * 0.001 << "s)" << std::endl;
  std::cout << "Total system time (sum of all game times): " << std::fixed << std::setprecision(2) << total_game_time << "s" << std::endl;
  std::cout << "Average game time: " << std::fixed << std::setprecision(3) << avg_game_time << "s" << std::endl;
  std::cout << "Score by formula: " << output_pts(avg_score) << std::endl;
}

int main() {
  concurrent_test_multiprocess();
  return 0;
}